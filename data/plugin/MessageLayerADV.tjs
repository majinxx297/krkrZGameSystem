/*------------------------------------------------------------------------------
/		Copyright (C) サークル煌明	All Rights Reserved.
/			MessageLayerADV - FadeCh機能追加
/ 
/-----------------------------------------------------------------------------*/
@if(__MESSAGELAYERADV_DEFINED__==0)
@set(__MESSAGELAYERADV_DEFINED__=1)

Scripts.execStorage("SubRoutine.tjs");
Scripts.execStorage("FadeChLayer.tjs");

class MessageLayerADV extends MessageLayer {
	var hankakuPitch = 0;		// 半角の字間

	var fadeChLayers = [];
	var processedfadeChLayers = [];

	var currentCh = 0;	// 現在最終状態に居ない Ch 数
	var movingCh = 0;	// 現在フェード中の Ch 数
	var cl;				// 現在processCh/putGraphが扱っているfadeChレイヤ

	var ch4Fade = true, defaultCh4Fade = true;
	var chfadetime = 400, defaultChfadetime = 400;

	var defaultEdgeExtent = edgeExtent; // 袋文字のふとさ
	var defaultEdgeEmphasis = edgeEmphasis; // 袋文字の強調度
	var defaultShadowOffsetX = shadowOffsetX; // 影のオフセット
	var defaultShadowOffsetY = shadowOffsetY; // 影のオフセット

	// ふらふら
	var chSlant = 0;
	var defaultChSlant = 0;
	// ロット。回転
	var chRot = 0;
	var defaultChRot = 0;
	// 回転ループ
	var chRotMode = "none", chRotLoopC, chRotRound;
	var defaultChRotMode = "none", defaultChRotLoopC, defaultChRotRound;
	// グラデーション
	var chGradMode = "none";	// ループ。モード
	var chGradLoopC;			// カウンタ
	var chGradation = [], chGradationArray = [], chGradRound;	// グラデーションの状態と、その差分
	var defaultChGradMode = "none";
	var defaultChGradLoopC;
	var defaultChGradation = [], defaultChGradationArray = [], defaultChGradRound;
	var tmpchloopCounter = 0;
	// ふらふらループ x y
	var chSxMode = "none", chSxLoopC, chSx, chSxRound;
	var defaultChSxMode = "none", defaultChSxLoopC, defaultChSx, defaultChSxRound;
	var chSyMode = "none", chSyLoopC, chSy, chSyRound;
	var defaultChSyMode = "none", defaultChSyLoopC, defaultChSy, defaultChSyRound;

	// 回転しながら出現
	var chRotMoveMode = "none", chRotMoveRound;
	var defaultChRotMoveMode = "none", defaultChRotMoveRound;
	// ふらふらしながら出現 x y
	var chSxMoveMode = "none", chSxMove;
	var defaultChSxMoveMode = "none", defaultChSxMove;
	var chSyMoveMode = "none", chSyMove;
	var defaultChSyMoveMode = "none", defaultChSyMove;

	var cx, cy;	// get_cx, get_cy
	var currentRubyAlign = "e"; // 次の文字に対するルビの割り付け方法

	var rubyBold = false;
	var rubyFace;
	var defaultRubyFace = "e";

	var rubyAlign;
	var defaultRubyAlign = "e";
	// 親文字字間拡張機能 (ルビ長が親文字より長い際に親文字の字間を広げる機能)
	var rubyOverflow;
	var currentRubyOverflow;	// 次のchの字間拡張サイズ
	var defaultRubyOverflow;

	var id__ = 0;

	function MessageLayerADV() {
		super.MessageLayer(...);
	}

	function finalize() {
		forEachFadeChFinish();
		super.finalize(...);
	}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @文字列をフェード表示
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
	function clearLayer() {
		super.clearLayer(...);
		forEachFadeChClear();
	}

	function fixLineLayer() {
		super.fixLineLayer(...);
		forEachFadeChFloat();
	}

	function reline() {
		// ページを越える場合は true, 越えないで改行できる場合は false
		var n = super.reline(...);
		if(n) forEachFadeChFloat();
		
		return n;
	}

	function reline2() {
	}

	function initLineLayer() {
		// lineLayer の初期化
		with(lineLayer) {
			resetLineSize();
			lineLayerLinks.count = 0;
			lineLayerOriginX = x;
			lineLayerOriginY = y;

			if(!vertical) {
				.imageWidth = imageWidth + 8;
			} else {
				.imageHeight = imageHeight + 8;
			}
			.setSizeToImageSize();
			changeLineSize(/*forceresize=*/true);
			lineLayerLength = 0;
			lineLayerPos = 0;
		//	.visible = false;
			.face = dfAuto;
			var lliw = .imageWidth;
			var llih = .imageHeight;
			.fillRect(0, 0, lliw, llih, 0);	// 完全透明に
			.face = dfProvince;
			.fillRect(0, 0, lliw, llih, 0);	// 領域をクリア
			.face = dfAuto;
		}
	}

	function getLineLayerBaseLine() {
		// 文字表示用のベースラインを計算して返す
		// 横書きの場合は文字の下端部分、
		// 縦書きの場合は文字の中央線
		if(!vertical)
			return -getLineLayerTopOffset() + lineSpacing + lineSize;
		else
			// 縦書き
			// 中央線(レイヤ左端からの位置)
			return (lineSize>>1);
	}

	function getLineLayerLeftOffset() {
		// 行描画用レイヤ内での左オフセットを取得
		if(!vertical) {
			if(align == -1)
				return 0;
			else if(align == 0)
				return ((imageWidth - marginR - marginL - lineLayerLength)>>1);
			else if(align == 1)
				return imageWidth - marginR - marginL - lineLayerLength;
		} else {
			return -lineSize - lineSpacing;
		}
	}

	function getLineLayerTopOffset() {
		// 行描画用レイヤ内での上オフセットを取得
		if(!vertical) {
			return -(lineLayer.imageHeight - lineSize - lineSpacing);
		} else {
			if(align == -1)
				return 0;
			else if(align == 0)
				return ((imageHeight - marginB - marginT - lineLayerLength)>>1);
			else if(align == 1)
				return imageHeight - marginB - marginT - lineLayerLength;
			return 0;
		}
	}

	function changeLineSize(forceresize = false) {
		// 行サイズが変更されたときに行描画用レイヤのサイズを変更するために
		// 呼ばれる
		var ll = lineLayer;
		if(inLink!=-1) endLinkLine();
		decideSizeChange();

		var oldWidth = ll.imageWidth;
		var oldHeight = ll.imageHeight;

		var newlinesize = (fontSize>lineSize) ? fontSize : lineSize;
		var newlinelayersize = newlinesize
			 + ((rubySize+rubyOffset>lineSpacing) ? rubySize+rubyOffset : lineSpacing) + 8;

		if(!vertical) {
			// 横書きの場合
			if(forceresize || ll.imageHeight<newlinelayersize) {
				// 行間拡張
				lineSize = newlinesize;
				ll.imageHeight = newlinelayersize;
				ll.setSizeToImageSize();
				lineLayerBase = getLineLayerBaseLine();
				// 内容移動
				if(!forceresize) {
					var newHeight = ll.imageHeight;
					var d = ll.imageHeight - oldHeight;
					ll.face = dfAuto;
					ll.copyRect(0, d, ll, 0, 0, oldWidth, newHeight);
					ll.fillRect(0, 0, oldWidth, d, 0);

					ll.face = dfProvince;
					ll.copyRect(0, d, ll, 0, 0, oldWidth, newHeight);
					ll.colorRect(0, 0, oldWidth, d, 0);
					ll.face = dfAuto;

/*__OVERRIDE__*/	forEachFadeChMove(0, d);
				}
				for(var i = 0; i<lineLayerLinks.count; i++) {
					var n = lineLayerLinks[i].number;
					var l = lineLayerLinks[i].line;
					links[n].y[l] += ll.imageHeight - oldHeight;
				}
				// 位置移動 
				ll.setPos(lineLayerOriginX + getLineLayerLeftOffset(),
							lineLayerOriginY + getLineLayerTopOffset());
			}
		} else {
			// 縦書きの場合
			if(forceresize || oldWidth < newlinelayersize) {
				// 行間拡張
				lineSize = newlinesize;
				var oldbase = lineLayerBase;
				ll.imageWidth = newlinelayersize;
				ll.setSizeToImageSize();
				lineLayerBase = getLineLayerBaseLine();
				// 内容移動
				if(!forceresize) {
					var newWidth = ll.imageWidth;
					var d = lineLayerBase - oldbase;
					ll.face = dfAuto;
					ll.copyRect(d, 0, ll, 0, 0, newWidth, oldHeight);
					ll.fillRect(0, 0, d, oldHeight, 0);
					ll.fillRect(oldWidth, 0, newWidth - (d + oldWidth), oldHeight, 0);

					ll.face = dfProvince;
					ll.copyRect(d, 0, ll, 0, 0, newWidth, oldHeight);
					ll.colorRect(0, 0, d, oldHeight, 0);
					ll.colorRect(d+oldWidth, 0, newWidth - (d + oldWidth), oldHeight, 0);
					ll.face = dfAuto;

/*__OVERRIDE__*/	forEachFadeChMove(-d, 0);
				}
				for(var i = 0; i < lineLayerLinks.count; i++) {
					var n = lineLayerLinks[i].number;
					var l = lineLayerLinks[i].line;
					links[n].x[l] += lineLayerBase - oldbase;
				}
				// 位置移動 
				ll.setPos(lineLayerOriginX + getLineLayerLeftOffset(),
							lineLayerOriginY + getLineLayerTopOffset());
			}
		}
	}

	function adjustAlign() {
		var x = lineLayerOriginX + getLineLayerLeftOffset() - lineLayer.left;
		var y = lineLayerOriginY + getLineLayerTopOffset() - lineLayer.top;
		forEachFadeChMove(x, y);
		lineLayer.setPos(lineLayerOriginX + getLineLayerLeftOffset(),
			lineLayerOriginY + getLineLayerTopOffset());
	}


	function setRuby(text, align, overflow) {
		// 次の文字に対するルビを設定する
		currentRuby = text;
		currentRubyAlign = align!==void ? align : rubyAlign;
		currentRubyOverflow = overflow!==void ? overflow : rubyOverflow;
	}

	function processCh(ch) {
		changeLineSize() if sizeChanged;

		var ll = lineLayer;
		var llfont = ll.font;
		var cw = llfont.getTextWidth(ch);

		// 複数文字描画時の改行処理：2文字目以降の長さの伸びを考慮する
		var mch = cw-llfont.getTextWidth(ch[0]);

		// 改行処理
		if((vertical ? y+mch>=relinexpos : x+mch>=relinexpos ) && autoReturn) {
			if(( (lastDrawnCh=="" || wwLeading.indexOf(lastDrawnCh)==-1) && wwFollowing.indexOf(ch)==-1)
			 || (lastDrawnCh!="" && wwFollowingWeak.indexOf(lastDrawnCh)!=-1 && wwFollowingWeak.indexOf(ch)!=-1)) {
				if(reline()) return autoReturn;
			} else if(vertical ? ( y+mch>imageHeight ) : (x+mch>imageWidth)) {
				if(reline()) return autoReturn;
			}
		}

		var inlink = inLink != -1;
		beginLinkLine() if inlink;

	// スキップ入り
		if(processChnInF && currentCh) { forEachFadeChFinish(); }

		cl = getFadeChLayer();	// フェード用レイヤ
		set_chSR(cl);

		with(cl) {
			if(currentRuby != "") {
				.setRuby(currentRuby, currentRubyAlign);
				currentRuby = "";	// セットしたからもう要らない
			}

			var in_x, in_y, dr_x, dr_y, _width, _height;
			if(vertical) {
				in_x = set_cx(lineLayerBase - (fontSize>>1)); in_y = lineLayerPos;
				dr_x = fontSize; dr_y = set_cy(0);
				_width = fontSize + rubySize + rubyOffset;
				_height = cw;
			} else {
				in_x = lineLayerPos; in_y = 0;
				dr_x = set_cx(0); dr_y = set_cy(lineLayerBase - fontSize);
				_width = cw;
				_height = ll.imageHeight;
			}
			.initChLayer(in_x, in_y, _width, _height);

			if(edge) {
				.expandLayer(edgeExtent, edgeExtent);
				.drawText(dr_x, dr_y, ch, get_chColor(), 255, 
					antialiased, edgeEmphasis, edgeColor, edgeExtent, 0, 0);
			} else if(shadow) {
		//		shadowOffsetX=-10, shadowOffsetY=-10;	// テスト

				.expandLayer(shadowOffsetX, shadowOffsetY);
				.drawText(dr_x, dr_y, ch, get_chColor(), 255, 
					antialiased, 255, shadowColor, 0, shadowOffsetX, shadowOffsetY);
			} else {
				.drawText(dr_x, dr_y, ch, get_chColor(), 255, antialiased);
			}

			// ※ルビ長が親文字より長い際に、親文字の字間を広げる機能 (FadeChLayer)
			if(.ruby!="") {
				cw += .textExpandLength;
			}
		}

		ll.visible = true;

		if(inlink) {
			// ハイパーリンクでちゅー
			ll.face = dfProvince;
			if(!vertical)
				ll.fillRect(lineLayerPos, lineLayerBase - fontSize, cw, fontSize, numLinks + 1);
			else
				ll.fillRect(lineLayerBase - (fontSize>>1), lineLayerPos, fontSize, cw, numLinks + 1);

			// 領域画像も塗りつぶしてやる
			ll.face = dfAuto;
			linkFilled = true;
		}

		cw += pitch;

		if(vertical) y += cw; else x += cw;

		lineLayerPos += cw;
		lineLayerLength += cw;

		lastDrawnCh = ch;

		adjustAlign() if(align >= 0);

		return false;
	}

	function putGraph(storage, key, ischar) {
		var ll = lineLayer;

		// テンポラリのレイヤを用意
		var lay = window.temporaryLayer;

		lay.type = ltTransparent;
		lay.face = dfAuto;
		lay.loadImages(storage, key); // 画像読み込み

		var lw = lay.imageWidth, lh = lay.imageHeight;

		changeLineSize();

		if(inLink != -1) beginLinkLine();

		if(autoReturn && (vertical?(y>relinexpos):(x>relinexpos)) )
			if(reline()) return true;		// 改行位置に達している？


		cl = getFadeChLayer();
		set_chSR(cl);

		var cw = vertical ? lh : lw;
		var in_x, in_y, dr_x, dr_y;

		if(currentRuby != "") {
			cl.setRuby(currentRuby, currentRubyAlign);
			currentRuby = "";	// セットしたからもう要らない
		}

		if(vertical) {
			in_x = set_cx(lineLayerBase - (lw>>1)), in_y = lineLayerPos;
			dr_x = cx; dr_y = set_cy(0);
		} else {
			in_x = set_cx(0); in_y = lineLayerPos;
			dr_x = 0; dr_y = set_cy(lineLayerBase - lh);
	//		in_x = lineLayerPos; in_y = 0;
	//		dr_x = set_cx(0); dr_y = set_cy(lineLayerBase - lh);
			lh += dr_y;
		}

		cl.initChLayer(in_x, in_y, lw, lh);
		if(ischar) {

			lay.face = dfOpaque;
			lay.holdAlpha = true;
			var ee = edgeExtent;

			if(edge) {
				cl.expandLayer(ee, ee);
				lay.fillRect(0, 0, lw, lh, edgeColor);
			//	lay.doBoxBlur(ee, ee);
				var tmp2Layer = new global.Layer(window, kag.fore.base);
				tmp2Layer.width = lw+ee*2;
				tmp2Layer.height = lh+ee*2;
				tmp2Layer.operateRect(ee, ee, lay, 0, 0, lw, lh, omAlpha, 255);
				tmp2Layer.doBoxBlur(ee, ee);

				var n = edgeEmphasis\128;
				for(var i=0;i<n;i++){
					cl.operateRect(dr_x, dr_y, tmp2Layer, 0, 0, lw+ee*2, lh+ee*2, omAlpha, 128);
				}
			//	cl.doBoxBlur(ee, ee);
			} else if(shadow) {
				// 影
				var sX = shadowOffsetX, sY = shadowOffsetY;
				cl.expandLayer(sX, sY);

				lay.fillRect(0, 0, cl.width, cl.height, shadowColor);
				cl.operateRect(dr_x+Math.abs(sX)+sX, dr_y+Math.abs(sX)+sY,
					lay, 0, 0, cl.width, cl.height);
			}
			lay.fillRect(0, 0, lw, lh, get_chColor());
		}
		cl.drawGraph(dr_x, dr_y, lay, 0, 0, lw, lh);

		// 描画おわり
		lastDrawnCh="";

		if(inLink!=-1) {
			// ハイパーリン クでちゅー
			lineLayer.face = dfProvince;
			if(vertical)
				lineLayer.fillRect(lineLayerBase - (fontSize>>1), lineLayerPos,
					fontSize, cw, numLinks+1);
			else
				lineLayer.fillRect(lineLayerPos, lineLayerBase - fontSize,
					cw, fontSize, numLinks+1);
			face = dfAuto;
			lineLayer.face = dfBoth;
			// 領域画像も塗りつぶしてやる
			linkFilled=true;
		}

		if(vertical) { y+=cw; } else { x+=cw; }
		lineLayerPos += cw;
		lineLayerLength += cw;  

		lineLayer.visible = true;

		adjustAlign() if(align >= 0);

		return false;
	}

	function putHorizonCh(text, expand = false) {
		// 縦中横を描画する
		if(!vertical) throw new Exception("縦書きモードでないと使用できません");

		// フォントを設定し直す
		var ll = lineLayer;
		var lf = ll.font;
		var orgfont = lf.face;
		var organgle = lf.angle;

		var lff = orgfont.split('@', , true); // 先頭の @ マークを取り除く
		lf.face = (string)lff[-1];
		lf.angle = 0;

		// 描画する文字の横幅を取得
		var cw = lf.getTextWidth(text);
		var ch = lf.getTextHeight(text);

		// リンク中の場合はリンクを開始
		if(inLink != -1) beginLinkLine();

		// 改行/改ページ処理
		var repage = false;
		// 改行位置に達している？
		if(autoReturn && y > relinexpos) repage = reline();
		if(repage) {
			// 戻る前にフォントをもとにもどす
			lf.face = orgfont;
			lf.angle = organgle;
			return true; // 文字は描画しない
		}

		// linesize の拡張
		if(expand) {
			if(cw > lineSize) lineSize = cw; // 拡張
			changeLineSize();
		}

		// 描画
		with(cl = getFadeChLayer()) {
			.hch = true;	// 縦中横フラグ
			set_chSR(cl);
			if(currentRuby != "") {
				.setRuby(currentRuby, currentRubyAlign);
				currentRuby = "";	// セットしたからもう要らない
			}

			var in_x = set_cx(lineLayerBase - (cw>>1)); 
			var in_y = lineLayerPos;
			var dr_x = 0;
			var dr_y = set_cy(0);
			var _width = cw + rubySize + rubyOffset;
			var _height = ch;
			.initChLayer(in_x, in_y, _width, _height);

			if(edge) {
				.expandLayer(edgeExtent, edgeExtent);
				.drawHCHText(dr_x, dr_y, text, get_chColor(), 255, 
					antialiased, edgeEmphasis, edgeColor, edgeExtent, 0, 0);
			} else if(shadow) {
		//		shadowOffsetX=-10, shadowOffsetY=-10;	// テスト

				.expandLayer(shadowOffsetX, shadowOffsetY);
				.drawHCHText(dr_x, dr_y, text, get_chColor(), 255, 
					antialiased, 255, shadowColor, 0, shadowOffsetX, shadowOffsetY);
			} else {
				.drawHCHText(dr_x, dr_y, text, get_chColor(), 255, antialiased);
			}
		}
		cl.hch = false;	// 縦中横フラグ

		// 描画おわり
		lastDrawnCh="";

		// フォントを元に戻す
		lf.face = orgfont;
		lf.angle = organgle;

		// ハイパーリンクの処理
		if(inLink!=-1) {
			// ハイパーリンクでちゅー
			ll.face = dfProvince;
			ll.fillRect(lineLayerBase - (fontSize>>1), lineLayerPos,
				fontSize, cw, numLinks+1);
			face = dfAuto;
			ll.face = dfAuto;
			linkFilled=true;
		}

		ch += pitch;

		y += ch;
		lineLayerPos += ch;
		lineLayerLength += ch;

		lastDrawnCh = text;

		ll.visible = true;

		// アラインの修正
		adjustAlign() if(align >= 0);

		// 戻る
		return false;
	}

	function getFadeChLayer() {
		var cl_ = fadeChLayers.pop();
		if(cl_ === void) { 
			cl_ = new FadeChLayer(window, lineLayer);
			cl_.__id = id__++;
		}

		cl_.copyCondition();
		processedfadeChLayers.add(cl_);
		currentCh++;

		if(currentCh != processedfadeChLayers.count)
			dm('Fatal ERROR : currentChの値にエラーが発生');

		return cl_;
	}

	function putFadeChLayer(cl_) {
	// chレイヤ を待機状態にする
		processedfadeChLayers.remove(cl_, false);
		fadeChLayers.add(cl_);
		currentCh--;

		if(!currentCh) { movingCh = 0; }
	}

	function addMovingCh() {
		movingCh++;
	}

	function stopMovingCh() {
		movingCh--;
		// すべて写されていたらトリガを引く
		if(!movingCh && !processChnInF) { kag.conductor.trigger("fadeCh"); }
	}

	function waitFinishCh(elm) {
		if(movingCh) {
			forEachFadeChFloat();
			return global.kag.waitTrigger( %[
					canskip : elm.canskip = elm.canskip!==void ? elm.canskip : true,
					name : "fadeCh",
					onskip : "kag.current.forEachFadeChFinish()"
				] );
		} else {
			return 0;
		}
	}

	function forEachFadeChMove(x, y) {
	// 改行していない chレイヤ を動かす
		var i = currentCh;
		while(i--) { with(processedfadeChLayers[i]) { .changedChLinePos(x, y) if !.floated; } }
	}

	function forEachFadeChFloat() {
	// すべての chレイヤ の改行フラグを立てる
	// より以前に登録されたレイヤが先に改行フラグが立つ。
	// float() は転写処理が行われたらtrueを返す
		for(var i=0;i<currentCh;i++) {
			with(processedfadeChLayers[i]) { if(!.floated) if(.float()) i--; }
		}
	}

	function forEachFadeChFinish() {
	// すべての chレイヤ を最終状態に持ち込む
	// より以前に登録されたレイヤが先に最終状態になる。
	// finishLayerMoving() は転写処理が行われたらtrueを返す
		for(var i=0;i<currentCh;i++) {
			with(processedfadeChLayers[i]) { if(.finishLayerMoving()) i--; }
		}
	}

	function forEachFadeChClear() {
	// すべての chレイヤ を、メッセージレイヤに内容を移すことなく待機状態に戻す
		while(currentCh) {
			processedfadeChLayers[-1].stopLayerMoving();
			processedfadeChLayers[-1].resetChLayer();
			putFadeChLayer(processedfadeChLayers[-1]);
		}
	}

	property processChnInF {
		getter() {
			// 演出をしていないならTrue、しているならFalse
			return (kag.skipMode >= 2 || kag.actualChSpeed < 10);
		}
	}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @レンダリングフォント
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
	function mapPrerenderedFont(storage) {
		// レンダリング済みフォントを現在の操作対象のレイヤに選択
		// されているフォントにマッピングする
		current.decideSizeChange();
		current.font.mapPrerenderedFont(storage);
//		current.lineLayer.font.mapPrerenderedFont(storage);
	}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @トランジション
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
	function beginTransition(elm) {
		super.beginTransition(elm, comp);
	}

	function assignComp() {
		super.assignComp();
		// compの方から持ってくる
		forEachFadeChClear();
		var i = comp.currentCh;
		while(i--) {
			var __ch = getFadeChLayer();
			__ch.assign(comp.processedfadeChLayers[i]);
		}
		movingCh = comp.movingCh;
	}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @文字エフェクト・周期的を追加
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
	function get_chColor() {
		var ge = chColor;
		if(chGradMode=="none") return ge;	// モード指定無し

		if(chGradationArray[0] === void) {
			gradationX( parseColor2Array(chGradation), chGradRound, chGradationArray );
		}
		if(chGradMode=="grad") {	// グラデ
			ge = chGradationArray[chGradLoopC];
			if(chGradLoopC<chGradRound-1) {chGradLoopC++;} else {chGradLoopC = 0;}
		} else if(chGradMode=="gradloop") {	// グラデ・ループ
			ge = chGradationArray[chGradLoopC];
			if(chGradRound>0) {
				if(chGradLoopC<chGradRound-1) {chGradLoopC++;}else{chGradRound = -chGradRound;}
			} else { if(chGradLoopC>0) {chGradLoopC--;}else{chGradRound = -chGradRound;} }
		} else if(chGradMode=="gradrandom") {	// グラデ・ランダム
			ge = chGradationArray[ int(Math.floor(Math.random()*chGradRound)) ];
		}
		return ge;
	}

	function set_cx(_cx) {
		if(chSxMode=="sin") {	// サインカーブ
			if(chSxLoopC<chSxRound-1) {chSxLoopC++;} else { chSxLoopC = 0; }
			cl.setSlant(chSx*Math.sin(6.2831*chSxLoopC/chSxRound), 0);
		}
		// 出現
		if(chSxMoveMode=="random") {
			cl.setSlantMove(chSxMove*Math.random(), 0);
		} else if(chSxMoveMode=="valuerandom") {
			cl.setSlantMove(chSxMove*Math.random()*(Math.random()>0.5?1:-1), 0);
		} else if(chSxMoveMode=="value") {
			cl.setSlantMove((int)chSxMove, 0);
		}
		cx = _cx;
		return cx;
	}

	function set_cy(_cy) {
		if(chSyMode=="sin") {	// サイン
			if(chSyLoopC<chSyRound-1) {chSyLoopC++;} else { chSyLoopC = 0; }
			cl.setSlant( 0, chSy*Math.sin(6.2831*chSyLoopC/chSyRound) );
		}
		if(chSyMoveMode=="random") {
			cl.setSlantMove(0,chSyMove*Math.random());
		} else if(chSyMoveMode=="valuerandom") {
			cl.setSlantMove(0, chSyMove*Math.random()*(Math.random()>0.5?1:-1));
		} else if(chSyMoveMode=="value") {
			cl.setSlantMove(0, (int)chSyMove);
		}
		cy = _cy;
		return cy;
	}

	function set_chSR(cl_) {
		if(chSlant!=0) {	// ランダムゆらぎ
			cl_.setSlant(
				int(Math.random() *chSlant* (Math.random()>0.5?1:-1)), 
				int(Math.random() *chSlant* (Math.random()>0.5?1:-1))
			);
		}

		if(chSxMode=="none" && chSx!=0) {
			cl_.setSlant( int(Math.random() *chSx* (Math.random()>0.5?1:-1)), 0 );
		}
		if(chSyMode=="none" && chSy!=0) {
			cl_.setSlant( 0, int(Math.random() *chSy* (Math.random()>0.5?1:-1)) );
		}

		if(chRotMode=="none" && chRot!=0) {	// ランダム回転
			cl_.setRad( int(Math.random() * chRot * (Math.random()>0.5?1:-1)) );
		}

		if(chRotMode=="sin") {	// 周期的サインカーブ (0～chRot)
			cl_.setRad( chRot*Math.sin(1.5707*chRotLoopC/chRotRound) );
			if(chRotLoopC<chRotRound-1) { chRotLoopC++; } else { chRotLoopC=0; }
		} else if(chRotMode=="sinloop") {	// 周期的サインカーブ (0～chRot～0～-chRot～0)
			cl_.setRad( chRot*Math.sin(6.2831*chRotLoopC/chRotRound) );
			if(chRotLoopC<chRotRound-1) { chRotLoopC++; } else { chRotLoopC=0; }
		}

	// 出現
		if(chRotMoveMode=="random") {
			cl_.setRadMove( int(chRotMoveRound*Math.random()) );
		} else if(chRotMoveMode=="valuerandom") {
			cl_.setRadMove( int(chRotMoveRound*Math.random()*(Math.random()>0.5?1:-1)) );
		} else if(chRotMoveMode=="value") {
			cl_.setRadMove( int(chRotMoveRound) );
		}
	}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @スタイル設定追加・セーブロード部分
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
	function resetFont() {
		edgeExtent	=	defaultEdgeExtent;
		edgeEmphasis	=	defaultEdgeEmphasis;
		shadowOffsetX	=	defaultShadowOffsetX;
		shadowOffsetY	=	defaultShadowOffsetY;
		rubyFace		=	defaultRubyFace;
		rubyAlign		=	defaultRubyAlign;
		rubyOverflow	=	defaultRubyOverflow;
		super.resetFont();
	}

	function setFont(elm) {
		if(elm.edgeextent == 'default')			edgeExtent = defaultEdgeExtent;
		else if(elm.edgeextent !== void)		edgeExtent = +elm.edgeextent;

		if(elm.edgeemphasis == 'default')		edgeEmphasis	=	defaultEdgeEmphasis;
		else if(elm.edgeemphasis !== void)		edgeEmphasis = +elm.edgeemphasis;

		if(elm.shadowoffsetx == 'default')		shadowOffsetX	=	defaultShadowOffsetX;
		else if(elm.shadowoffsetx !== void)		shadowOffsetX = +elm.shadowoffsetx;

		if(elm.shadowoffsety == 'default')		shadowOffsetY	=	defaultShadowOffsetY;
		else if(elm.shadowoffsety !== void)		shadowOffsetY = +elm.shadowoffsety;

		if(elm.rubyface == 'default')		rubyFace = defaultRubyFace;
		else if(elm.rubyface !== void)		rubyFace = elm.rubyface;
		if(elm.rubyalign == 'default')		rubyAlign = defaultRubyAlign;
		else if(elm.rubyalign !== void)		rubyAlign = elm.rubyalign;

		if(elm.rubyoverflow == 'default')		rubyOverflow = defaultRubyOverflow;
		else if(elm.rubyoverflow !== void)		rubyOverflow = elm.rubyoverflow;

		super.setFont(elm);
	}

	function setDefaultFont(elm) {
		// デフォルトフォントの設定
		defaultEdgeExtent = +elm.edgeextent if elm.edgeextent !== void;
		defaultEdgeEmphasis = +elm.edgeemphasis if elm.edgeemphasis !== void;
		defaultShadowOffsetX = +elm.shadowoffsetx if elm.shadowoffsetx !== void;
		defaultShadowOffsetY = +elm.shadowoffsety if elm.shadowoffsety !== void;
		defaultRubyFace = elm.rubyface if elm.rubyface !== void;
		defaultRubyAlign = elm.rubyalign if elm.rubyalign !== void;
		defaultRubyOverflow = elm.rubyoverflow if elm.rubyoverflow !== void;

		super.setDefaultFont(elm);
	}



	function setStyle(elm) {
		ch4Fade = elm.fade if elm.fade !== void;
		chfadetime = +elm.fadetime if elm.fadetime !== void;

		chSlant = +elm.slant if elm.slant!==void;
		chRot = +elm.rot if elm.rot!==void;
	// grad
		chGradMode = elm.gradmode if elm.gradmode !== void;
		chGradLoopC = 0 if elm.gradmode !== void;	// リセット
		chGradation = elm.gradation if elm.gradation !== void;
		chGradationArray = [];
		chGradRound = +elm.gradround if elm.gradround !== void;
	// sx
		chSxMode = elm.slantxmode if elm.slantxmode !== void;
		chSxLoopC = 0 if elm.slantxmode !== void;	// リセット
		chSx = +elm.slantx if elm.slantx !== void;
		chSxRound = +elm.slantxround if elm.slantxround !== void;
	// sy
		chSyMode = elm.slantymode if elm.slantymode !== void;
		chSyLoopC = 0 if elm.slantymode !== void;	// リセット
		chSy = +elm.slanty if elm.slanty !== void;
		chSyRound = +elm.slantyround if elm.slantyround !== void;

		chRotMode = elm.rotmode if elm.rotmode !== void;
		chRotLoopC = 0 if elm.rotmode !== void;;			// 強制リセット
		chRotRound = +elm.rotround if elm.rotround !== void;

	// 回転しながら出現
		chRotMoveMode = elm.rotmovemode if elm.rotmovemode !== void;
		chRotMoveRound = elm.rotmoveround if elm.rotmoveround !== void;
	// ふらふらしながら出現 x y
		chSxMoveMode = elm.sxmovemode if elm.sxmovemode !== void;
		chSxMove = +elm.sxmove if elm.sxmove !== void;
		chSyMoveMode = elm.symovemode if elm.symovemode !== void;
		chSyMove = +elm.symove if elm.symove !== void;

		super.setStyle(elm);
	}

	function setDefaultStyle(elm) {
		// デフォルトのスタイルの設定
		// オプション設定なので「書かなかったら無し」
		// ただし keepaddition が指定されてると、上書きしない限り前回指定したものをそのまま使う
		defaultCh4Fade = elm.fade if elm.fade !== void;
		defaultChfadetime = +elm.fadetime if elm.fadetime !== void;

		defaultChSlant = elm.slant !== void ? +elm.slant
			 : (elm.keepaddition ? defaultChSlant : 0);
		defaultChRot = elm.rot !== void ? +elm.rot
			 : (elm.keepaddition ?  defaultChRot: 0);
	// grad
		defaultChGradMode = elm.gradmode !== void ? 
			elm.gradmode : (elm.keepaddition ? defaultChGradMode : "none");
		defaultChGradation = elm.gradation !== void ? 
			elm.gradation : (elm.keepaddition ? defaultChGradation : void);
		defaultChGradRound = elm.gradround !== void ? 
			+elm.gradround : (elm.keepaddition ? defaultChGradRound : void);
		defaultChGradLoopC = 0;			// 強制リセット
		defaultChGradationArray = [];	// 強制リセット

		defaultChSxMode = elm.slantxmode !== void ? 
			elm.slantxmode : (elm.keepaddition ? defaultChSxMode : "none");
		defaultChSxLoopC = 0;			// 強制リセット
		defaultChSx = elm.slantx !== void ? 
			+elm.slantx : (elm.keepaddition ? defaultChSx : void);
		defaultChSxRound = +elm.slantxround !== void ? 
			+elm.slantxround : (elm.keepaddition ? defaultChSxRound : void);

		defaultChSyMode = elm.slantymode !== void ? 
			elm.slantymode : (elm.keepaddition ? defaultChSyMode : "none");
		defaultChSyLoopC = 0;			// 強制リセット
		defaultChSy = elm.slanty !== void ? 
			+elm.slanty : (elm.keepaddition ? defaultChSy : void);
		defaultChSyRound = +elm.slantyround !== void ? 
			+elm.slantyround : (elm.keepaddition ? defaultChSyRound : void);

		defaultChRotMode = elm.rotmode !== void ? 
			elm.rotmode : (elm.keepaddition ? defaultChRotMode : "none");
		defaultChRotLoopC = 0;			// 強制リセット
		defaultChRotRound = +elm.rotround !== void ? 
			+elm.rotround : (elm.keepaddition ? defaultChRotRound : void);

		// 回転しながら出現
		defaultChRotMoveMode = elm.rotmovemode !== void ? 
			elm.rotmovemode : (elm.keepaddition ? defaultChRotMoveMode : "none");
		defaultChRotMoveRound = elm.rotmoveround !== void ? 
			+elm.rotmoveround : (elm.keepaddition ? defaultChRotMoveRound : void);
		// ふらふらしながら出現 x y
		defaultChSxMoveMode = elm.sxmovemode !== void ? 
			elm.sxmovemode : (elm.keepaddition ? defaultChSxMoveMode : "none");
		defaultChSxMove = elm.sxmove !== void ? 
			+elm.sxmove : (elm.keepaddition ? defaultChSxMove : void);
		defaultChSyMoveMode = elm.symovemode !== void ? 
			elm.symovemode : (elm.keepaddition ? defaultChSyMoveMode : "none");
		defaultChSyMove = elm.symove !== void ? 
			+elm.symove : (elm.keepaddition ? defaultChSyMove : void);

		super.setDefaultStyle(elm);
	}

	function resetStyle() {
		// スタイルのリセット
		ch4Fade = defaultCh4Fade;
		chfadetime = defaultChfadetime;

		chSlant = defaultChSlant;
		chRot = defaultChRot;
		chGradMode = defaultChGradMode;
		chGradLoopC = defaultChGradLoopC;
		chGradation  = defaultChGradation;
		chGradationArray  = defaultChGradationArray;
		chGradRound = defaultChGradRound;

		chSxMode = defaultChSxMode;
		chSxLoopC = defaultChSxLoopC;
		chSx = defaultChSx;
		chSxRound = defaultChSxRound;

		chSyMode = defaultChSyMode;
		chSyLoopC = defaultChSyLoopC;
		chSy = defaultChSy;
		chSyRound = defaultChSyRound;

		chRotMode = defaultChRotMode;
		chRotLoopC = defaultChRotLoopC;
		chRotRound = defaultChRotRound;

		chRotMoveMode = defaultChRotMoveMode;
		chRotMoveRound = defaultChRotMoveRound;

		chSxMoveMode = defaultChSxMoveMode;
		chSxMove = defaultChSxMove;
		chSyMoveMode = defaultChSyMoveMode;
		chSyMove = defaultChSyMove;

		super.resetStyle();
	}

	function internalAssign(src, copyvisiblestate) {
		super.internalAssign(...);
		defaultCh4Fade = src.defaultCh4Fade;			ch4Fade = src.ch4Fade;
		defaultChfadetime = src.defaultChfadetime;	chfadetime = src.chfadetime;

		defaultChSlant = src.defaultChSlant;		chSlant = src.chSlant;
		defaultChRot = src.defaultChRot;		chRot = src.chRot;

		defaultChGradMode = src.defaultChGradMode;		chGradMode = src.chGradMode;
		defaultChGradLoopC = src.defaultChGradLoopC;	chGradLoopC = src.chGradLoopC;
		defaultChGradation = src.defaultChGradation;	chGradation = src.chGradation;
		defaultChGradationArray = src.defaultChGradationArray;	chGradationArray = src.chGradationArray;
		defaultChGradRound = src.defaultChGradRound;	chGradRound = src.chGradRound;

		defaultChSxMode = src.defaultChSxMode;		chSxMode = src.chSxMode;
		defaultChSxLoopC = src.defaultChSxLoopC;	chSxLoopC = src.chSxLoopC;
		defaultChSx = src.defaultChSx;			chSx = src.chSx;
		defaultChSxRound = src.defaultChSxRound;	chSxRound = src.chSxRound;

		defaultChSyMode = src.defaultChSyMode;		chSyMode = src.chSyMode;
		defaultChSyLoopC = src.defaultChSyLoopC;	chSyLoopC = src.chSyLoopC;
		defaultChSy = src.defaultChSy;		chSy = src.chSy;
		defaultChSyRound = src.defaultChSyRound;	chSyRound = src.chSyRound;

		defaultChRotMode = src.defaultChRotMode;		chRotMode = src.chRotMode;
		defaultChRotLoopC = src.defaultChRotLoopC;	chRotLoopC = src.chRotLoopC;
		defaultChRotRound = src.defaultChRotRound;	chRotRound = src.chRotRound;

		defaultChRotMoveMode = src.defaultChRotMoveMode;		chRotMoveMode = src.chRotMoveMode;
		defaultChRotMoveRound = src.defaultChRotMoveRound;	chRotMoveRound = src.chRotMoveRound;

		defaultChSxMoveMode = src.defaultChSxMoveMode;	chSxMoveMode = src.chSxMoveMode;
		defaultChSxMove = src.defaultChSxMove;		chSxMove = src.chSxMove;
		defaultChSyMoveMode = src.defaultChSyMoveMode;		chSyMoveMode = src.chSyMoveMode;
		defaultChSyMove = src.defaultChSyMove;	chSyMove = src.chSyMove;

		edgeExtent = src.edgeExtent;		defaultEdgeExtent = src.defaultEdgeExtent;
		edgeEmphasis = src.edgeEmphasis;	defaultEdgeEmphasis = src.defaultEdgeEmphasis;
		shadowOffsetX = src.shadowOffsetX;	defaultShadowOffsetX = src.defaultShadowOffsetX;
		shadowOffsetY = src.shadowOffsetY;	defaultShadowOffsetY = src.defaultShadowOffsetY;

		rubyFace = src.rubyFace;	defaultRubyFace = src.defaultRubyFace;
		rubyAlign = src.rubyAlign;	defaultRubyAlign = src.defaultRubyAlign;
		rubyOverflow = src.rubyOverflow;	defaultRubyOverflow = src.defaultRubyOverflow;
	}

	function store() {
		var dic = super.store();

		dic.ch4Fade = ch4Fade;				dic.defaultCh4Fade = defaultCh4Fade;
		dic.chfadetime = chfadetime;		dic.defaultChfadetime = defaultChfadetime;

		dic.frameGraphic = frameGraphic;

		dic.defaultChSlant = defaultChSlant;		dic.chSlant = chSlant;
		dic.defaultChRot = defaultChRot;		dic.chRot = chRot;

		dic.defaultChGradMode = defaultChGradMode;		dic.chGradMode = chGradMode;
		dic.defaultChGradLoopC = defaultChGradLoopC;	dic.chGradLoopC = chGradLoopC;
		dic.defaultChGradation = defaultChGradation;	dic.chGradation = chGradation;
		dic.defaultChGradRound = defaultChGradRound;	dic.chGradRound = chGradRound;

		dic.defaultChSxMode = defaultChSxMode;		dic.chSxMode = chSxMode;
		dic.defaultChSxLoopC = defaultChSxLoopC;	dic.chSxLoopC = chSxLoopC;
		dic.defaultChSx = defaultChSx;		dic.chSx = chSx;
		dic.defaultChSxRound = defaultChSxRound;	dic.chSxRound = chSxRound;

		dic.defaultChSyMode = defaultChSyMode;		dic.chSyMode = chSyMode;
		dic.defaultChSyLoopC = defaultChSyLoopC;	dic.chSyLoopC = chSyLoopC;
		dic.defaultChSy = defaultChSy;		dic.chSy = chSy;
		dic.defaultChSyRound = defaultChSyRound;	dic.chSyRound = chSyRound;

		dic.defaultChRotMode = defaultChRotMode;		dic.chRotMode = chRotMode;
		dic.defaultChRotLoopC = defaultChRotLoopC;	dic.chRotLoopC = chRotLoopC;
		dic.defaultChRotRound = defaultChRotRound;	dic.chRotRound = chRotRound;

		dic.defaultChRotMoveMode = defaultChRotMoveMode;	dic.chRotMoveMode = chRotMoveMode;
		dic.defaultChRotMoveRound = defaultChRotMoveRound;	dic.chRotMoveRound = chRotMoveRound;

		dic.defaultChSxMoveMode = defaultChSxMoveMode;	dic.chSxMoveMode = chSxMoveMode;
		dic.defaultChSxMove = defaultChSxMove;		dic.chSxMove = chSxMove;
		dic.defaultChSyMoveMode = defaultChSyMoveMode;		dic.chSyMoveMode = chSyMoveMode;
		dic.defaultChSyMove = defaultChSyMove;	dic.chSyMove = chSyMove;

		dic.edgeExtent = edgeExtent;		dic.defaultEdgeExtent = defaultEdgeExtent;
		dic.edgeEmphasis = edgeEmphasis;	dic.defaultEdgeEmphasis = defaultEdgeEmphasis;
		dic.shadowOffsetX = shadowOffsetX;	dic.defaultShadowOffsetX = defaultShadowOffsetX;
		dic.shadowOffsetY = shadowOffsetY;	dic.defaultShadowOffsetY = defaultShadowOffsetY;

		dic.rubyFace = rubyFace;	dic.defaultRubyFace = defaultRubyFace;
		dic.rubyAlign = rubyAlign;	dic.defaultRubyAlign = defaultRubyAlign;
		dic.rubyOverflow = rubyOverflow;	dic.defaultRubyOverflow = defaultRubyOverflow;
		return dic;
	}

	function restore(dic) {
		defaultCh4Fade = dic.defaultCh4Fade if dic.defaultCh4Fade !== void;
		ch4Fade = dic.ch4Fade if dic.ch4Fade !== void;
		defaultChfadetime = dic.defaultChfadetime if dic.defaultChfadetime !== void;
		chfadetime = dic.chfadetime if dic.chfadetime !== void;

		defaultChSlant = dic.defaultChSlant if dic.defaultChSlant !== void;
		chSlant = dic.chSlant if  dic.chSlant !== void;
		defaultChRot = dic.defaultChRot if dic.defaultChRot !== void;
		chRot = dic.chRot if dic.chRot !== void;

		defaultChGradMode = dic.defaultChGradMode if dic.defaultChGradMode !== void;
		chGradMode = dic.chGradMode if dic.chGradMode !== void;
		defaultChGradLoopC = dic.defaultChGradLoopC if dic.defaultChGradLoopC !== void;
		chGradLoopC = dic.chGradLoopC if dic.chGradLoopC !== void;
		defaultChGradation = dic.defaultChGradation if dic.defaultChGradation !== void;
		chGradation = dic.chGradation if dic.chGradation !== void;
		defaultChGradRound = dic.defaultChGradRound if dic.defaultChGradRound !== void;
		chGradRound = dic.chGradRound if dic.chGradRound !== void;

		defaultChSxMode = dic.defaultChSxMode if dic.defaultChSxMode !== void;
		chSxMode = dic.chSxMode if dic.chSxMode !== void;
		defaultChSxLoopC = dic.defaultChSxLoopC if dic.defaultChSxLoopC !== void;
		chSxLoopC = dic.chSxLoopC if dic.chSxLoopC !== void;
		defaultChSx = dic.defaultChSx if dic.defaultChSx !== void;
		chSx = dic.chSx if dic.chSx !== void;
		defaultChSxRound = dic.defaultChSxRound if dic.defaultChSxRound !== void;
		chSxRound = dic.chSxRound if dic.chSxRound !== void;

		defaultChSyMode = dic.defaultChSyMode if dic.defaultChSyMode !== void;
		chSyMode = dic.chSyMode if dic.chSyMode !== void;
		defaultChSyLoopC = dic.defaultChSyLoopC if dic.defaultChSyLoopC !== void;
		chSyLoopC = dic.chSyLoopC if dic.chSyLoopC !== void;
		defaultChSy = dic.defaultChSy if dic.defaultChSy !== void;
		chSy = dic.chSy if dic.chSy !== void;
		defaultChSyRound = dic.defaultChSyRound if dic.defaultChSyRound !== void;
		chSyRound = dic.chSyRound if dic.chSyRound !== void;

		defaultChRotMode = dic.defaultChRotMode if dic.defaultChRotMode !== void;
		chRotMode = dic.chRotMode if dic.chRotMode !== void;
		defaultChRotLoopC = dic.defaultChRotLoopC if dic.defaultChRotLoopC !== void;
		chRotLoopC = dic.chRotLoopC if dic.chRotLoopC !== void;
		defaultChRotRound = dic.defaultChRotRound if dic.defaultChRotRound !== void;
		chRotRound = dic.chRotRound if dic.chRotRound !== void;

		defaultChRotMoveMode = dic.defaultChRotMoveMode if dic.defaultChRotMoveMode !== void;
		chRotMoveMode = dic.chRotMoveMode if dic.chRotMoveMode !== void;
		defaultChRotMoveRound = dic.defaultChRotMoveRound if dic.defaultChRotMoveRound !== void;
		chRotMoveRound = dic.chRotMoveRound if dic.chRotMoveRound !== void;

		defaultChSxMoveMode = dic.defaultChSxMoveMode if dic.defaultChSxMoveMode !== void;
		chSxMoveMode = dic.chSxMoveMode if dic.chSxMoveMode !== void;
		defaultChSxMove = dic.defaultChSxMove if dic.defaultChSxMove !== void;
		chSxMove = dic.chSxMove if dic.chSxMove !== void;
		defaultChSyMoveMode = dic.defaultChSyMoveMode if dic.defaultChSyMoveMode !== void;
		chSyMoveMode = dic.chSyMoveMode if dic.chSyMoveMode !== void;
		defaultChSyMove = dic.defaultChSyMove if dic.defaultChSyMove !== void;
		chSyMove = dic.chSyMove if dic.chSyMove !== void;

		edgeExtent = dic.edgeExtent;		defaultEdgeExtent = dic.defaultEdgeExtent;
		edgeEmphasis = dic.edgeEmphasis;	defaultEdgeEmphasis = dic.defaultEdgeEmphasis;
		shadowOffsetX = dic.shadowOffsetX;	defaultShadowOffsetX = dic.defaultShadowOffsetX;
		shadowOffsetY = dic.shadowOffsetY;	defaultShadowOffsetY = dic.defaultShadowOffsetY;
		rubyFace = dic.rubyFace;	defaultRubyFace = dic.defaultRubyFace;
		rubyAlign = dic.rubyAlign;	defaultRubyAlign = dic.defaultRubyAlign;
		rubyOverflow = dic.rubyOverflow;	defaultRubyOverflow = dic.defaultRubyOverflow;
		super.restore(dic);
	}
}



/* -----------------------------------------------------------------------------
/  KAG分
/ --------------------------------------------------------------------------- */
/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @拡張メッセージレイヤを作成するようにする
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
kag.org_allocateMessageLayers = kag.allocateMessageLayers;
kag.allocateMessageLayers = function(num, setdefaultfont = true) {
	// メッセージレイヤ数を num に設定する
	if(fore.messages.count > num) {
		// レイヤが減る
		for(var i = num; i<fore.messages.count; i++) {
			if(current == fore.messages[i] || current == back.messages[i])
				current = fore.messages[0], currentNum = 0, currentPage = 0;
			invalidate fore.messages[i];
			invalidate back.messages[i];
		}
		fore.messages.count = num;
		back.messages.count = num;
	}
	else if(fore.messages.count < num) {
		// レイヤが増える
		var cnt = fore.messages.count;
		for(var i=cnt; i<num; i++) {
			fore.messages[i] = new MessageLayerADV(this, fore.base, "表メッセージレイヤ" + i, i, true);
			back.messages[i] = new MessageLayerADV(this, back.base, "裏メッセージレイヤ" + i, i, true);
			fore.messages[i].setCompLayer(back.messages[i]);
			back.messages[i].setCompLayer(fore.messages[i]);
			fore.messages[i].clear();
			back.messages[i].clear();
		}
		reorderLayers();
		if(setdefaultfont) setMessageLayerUserFont();
		if(cnt==0) {
			setCurrentMessageLayer(%[page:"fore", layer:"message0"]);
		}
	}
	numMessageLayers = num;
} incontextof kag;

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @タグ新規作成・オーバーライド
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
// @ruby - ルビ振り
kag.tagHandlers.messageLayerADV_org_ruby = kag.tagHandlers.ruby;
kag.tagHandlers.ruby = function(elm) {
	elm.overflow = elm.of if(elm.of!==void);
	if(currentWithBack) current.comp.setRuby(elm.text, elm.align, elm.overflow);
	current.setRuby(elm.text, elm.align, elm.overflow);

	return 0;
} incontextof kag;

// @waitFadeCh - FadeCh終了を待つ
kag.tagHandlers.waitfadech = function(elm) {
	if(current.processChnInF)
		return 0;
	else
		return current.waitFinishCh(elm);
} incontextof kag;

// @finishFadeCh - カレントの、現在プロセス中の Ch を最終状態に持ち込む
kag.tagHandlers.finishfadech = function(elm) {
	return current.forEachFadeChFinish();
} incontextof kag;

kag.processUnKnownTag = function(tagname, elm) {
// ここから直接 tagHandlers にアクセスしても大丈夫。なハズ。
	if((string)tagname.indexOf("r_", 0)==0) {
	// [r_%1_○○]		-	○○部分がルビ指定。%1部分が割り付け指定
		if((string)tagname.indexOf("r_c_", 0)==0) {
			elm.text = (string)tagname.replace(/^r_c_/,);
			elm.align = "c";
		} else if((string)tagname.indexOf("r_r_", 0)==0) {
			elm.text = (string)tagname.replace(/^r_r_/,);
			elm.align = "r";
		} else if((string)tagname.indexOf("r_l_", 0)==0) {
			elm.text = (string)tagname.replace(/^r_l_/,);
			elm.align = "l";
		} else {
			elm.text = (string)tagname.replace(/^r_/,);
		}
		return tagHandlers.ruby(elm);
	} else if((string)tagname.indexOf("ch_", 0)==0) {
	// [ch_○○]		-	○○部分がtext指定
		elm.text = (string)tagname.replace(/^ch_/,);
		return tagHandlers.ch(elm);
	} else if((string)tagname.indexOf("hch_", 0)==0) {
		elm.text = tagname.substring(4);
//		elm.hch = true;
		elm.expand = true;
		return tagHandlers.hch(elm);
	} else {
		return -1;
	}
} incontextof kag;

kag.messageLayerADV_org_onConductorUnknownTag = kag.onConductorUnknownTag;
kag.onConductorUnknownTag = function(tagname, elm) {
	var n = processUnKnownTag(tagname, elm);
	if(n!==-1) {
		return n;
	} else {
		throw new Exception('タグ/マクロ \''+tagname+'\' は存在しません');
		return 0; // この戻り値は、各タグハンドラが返す物とおなじ
	}
} incontextof kag;

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @ MessageLayerをMessageLayerADVに置き換える
/ current が kag.fore.messages[0] に再設定される
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
if (kag.fore.messages[0] instanceof "MessageLayer") {
	var i = kag.fore.messages.count;
	kag.allocateMessageLayers(0);
	kag.allocateMessageLayers(i);
}

@endif
