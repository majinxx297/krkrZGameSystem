/*-----------------------------------------------------------------------------
/		Copyright (C) サークル煌明	All Rights Reserved.
/			SubRoutine Ver.0.1X
/ サブルーチン
/----------------------------------------------------------------------------*/
@if(__SUBROUTINE_DEFINED__==0)
@set(__SUBROUTINE_DEFINED__=1)

/*-----------------------------------------------------------------------------
/ @ 進行度の加速度的変化	Ver.0.21
/		加減速させた進行度を返す。-2 以下で初期に加速、2 以上で後期に加速
/		per		: 進行度
/		accel	: 加速度	accel<=-2(減速) 2<=accel(加速)
/ Math.pow = 乗数計算
/	calcPerSin	: 加速度を持って sin 進行
/	calcPerCos	: 加速度を持って cos 進行
/----------------------------------------------------------------------------*/
function calcPerAccel(per, accel) {
	if(accel<=-2)
		return per = 1.0 - Math.pow(1.0-per, -accel);
	else if(accel>=2)
		return per = Math.pow(per, accel);
	else
		return per;
}
function calcPerSin(per, accel) {
	return per = Math.sin(2*Math.PI*calcPerAccel(per, accel));
}
function calcPerCos(per, accel) {
	return per = Math.cos(2*Math.PI*calcPerAccel(per, accel));
}

/*-----------------------------------------------------------------------------
/ @	任意色間グラデーション用配列を生成する
/		16進数6桁のカラーを引数([c1, c2, c3...])にとり、
/		長さnの任意色間グラデーション配列を生成し、配列pに格納する
/
/ ここのソースを元にしましたぜ
/ http://www.graviness.com/virgo/javascript/d011211.html
/----------------------------------------------------------------------------*/
function gradationX( c, n, p ) {
	var s = c.count-1;
	if(s==1) {
		// 2値なら普通に返す
		// 3値もよく使われるらしいが、専用に作ってもそんな速度変わらんかった
		return gradation2side( c[0], c[1], n, p );
	} else {
		var m = Math.floor( n/s );	// 各rex要素の長さ。切り捨て
		var q = ( n-m*s )/s;		// 切り捨てで出た誤差の1グラデ当りの量
		var k = 0;					// 誤差修正用

		for(var i=0;i<s;i++) {
		// 最終グラデ以外は予め1伸ばし、i番目の最後とi+1番目の最初の色が重複する
		// ので生成後に削除する。
			var m2 = (i==s-1)?m:m+1;	// 最終グラデ以外は1伸ばし
		// 誤差を足していき、1を超えたらその2値のグラデは1伸ばす
			if( (k+=q) >= 1 ) { --k; ++m2; }
			gradation2side( c[i], c[i+1], m2, p );
			if(i<s-1) p.erase(-1);	// ケツは重複するので削除
		}

		return p;
	}
}

/*-----------------------------------------------------------------------------
/ @	2色間グラデーション用配列を生成する
/		16進数6桁のカラーを引数(p0,p1)にとり
/		長さnの2色間グラデーション配列を生成してpに入れる
/ 泥い方法で少しだけ速く
/----------------------------------------------------------------------------*/
function gradation2side( p0, p1, n, p ) {
	var c0=[] = toRGB(p0), c1=[] = toRGB(p1), dcr, dcg, dcb;
	var pc = p.count;

	dcr = (c1[0]-c0[0])/(n-1);	// RGBオフセット計算
	dcg = (c1[1]-c0[1])/(n-1);
	dcb = (c1[2]-c0[2])/(n-1);
	// オフセット加算しつつ16進数6桁に再生成
	p[pc++] = ( ((c0[0])<<16)|((c0[1])<<8)|(c0[2]) );	// 1発目オフセ無し
	while(--n)
		p[pc++] = ( ((c0[0]+=dcr)<<16)|((c0[1]+=dcg)<<8)|(c0[2]+=dcb) );
	return p;
}

/*-----------------------------------------------------------------------------
/ @	0xFFFFFF が連なった文字列を配列にする
/		デミリタは , 
/		すでに数字、配列になっているものはそのまま返す(はず)
/----------------------------------------------------------------------------*/
function parseColor2Array(color) {
	var res = color!==void	? color	: 0x000000;
	if(typeof res==="String" && res.indexOf(",")!==-1)
		return res.split(",", ,true);

	return res;
}

/*-----------------------------------------------------------------------------
/ @	十進数色指定を十六進数色指定にする
/	255, 255, 0, 255 => 0xFFFF00FF
/	   , 255, 0, 255 => 0xFF00FF
/----------------------------------------------------------------------------*/
function ten2sixt(a, b, c, d) {
	return (a<<24)|(b<<16)|(c<<8)|d;
}

function toHEX(r, g, b) {
	return (r<<16)|(g<<8)|(b);
}

/*-----------------------------------------------------------------------------
/ @	十六進数色指定を十進数色指定にする
/		[r, g, b] の配列を返す
/	0xFF00FF => [255, 0, 255]
/----------------------------------------------------------------------------*/
function toRGB( p ) {
	return [ (p & 0xff0000)>>>0x10, (p & 0x00ff00)>>>0x08, (p & 0x0000ff)>>>0x00 ];
}

/*-----------------------------------------------------------------------------
/ @	前 -> 後ろの順で選択する	Ver.0.10
/	i に値があるなら i、無いなら els を返す
/----------------------------------------------------------------------------*/
function autoSelect(i, els) {
	return i!==void ? i : els;
}

@endif
